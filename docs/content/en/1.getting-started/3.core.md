---
title: Core
description:
navigation:
  icon: i-lucide-cpu
seo:
  description:
---

Ody Core is the heart of the validation engine. It provides the schema architecture, the rule pipeline, common options (optional, nullable, default, array), as well as the `parse()` and `safeParse()` validation methods.

This page explains in detail how Ody works internally, how a schema is structured, and how rules are executed.

---

## Core Objectives

* Provide a **fast**, **modular**, and **extensible** validation engine.
* Offer a **modern DX**.
* Rely on a **clear pipeline** of validators and transformers.
* Make writing new schema types as simple as possible.

---

## Schema Structure in Ody

Every Ody schema extends the `BaseSchema<T>` class. This class:

* manages common options (`optional`, `nullable`, `default`, etc.);
* stores an ordered list of validation/transformation rules;
* executes these rules in the `parse()` method.

### Minimal Example

```ts [Minimal example]
import * as o from  "ody/core";

class MySchema extends o.BaseSchema<string> {
  constructor() {
    super("mySchema", [
      {
        schema: "string",
        type: "validator",
        params: {
          args: undefined,
          error: "must be a string"
        }
      }
    ]);
  }
}

const name = new MySchema();
await name.parse("John"); // OK
```

---

## The Pipeline: Validators & Transformers

An Ody schema contains a list of steps called the **pipeline**.

Each step is defined as:

```ts
export type SchemaOutput =
  | {
      schema: string;
      type: "validator";
      params: { args?: any; error?: string };
    }
  | {
      schema: string;
      type: "transformer";
      params: { args?: any };
    };
```

### Step Types

| Type          | Description                     | Usage                             |
| ------------- | ------------------------------- | --------------------------------- |
| `validator`   | checks a condition on the value | `min(3)`, `email()`, `isNumber()` |
| `transformer` | modifies the value              | `trim()`, `toLowerCase()`         |

Validators use the global `validators[schemaName]` function to execute the rule.

Transformers directly modify the value before passing it to the next rule.

---

## Built-in Options (optional, nullable, default, array)

Ody Core provides several helpers that all schemas can use.

### `optional()`

Marks the value as optional (`undefined` allowed).

### `nullable()`

Allows `null`.

### `nullish()`

Allows `null` **and** `undefined`.

### `default(value)`

Applies a default value if none is provided.

### `array()`

Transforms the current schema into:

* **an array of the current type**, with the same rules applied to each element.

```ts
o.string().min(3).array();
```

---

## How `parse()` Works

The `parse()` method runs sequentially:

1. the options (`optional`, `nullable`, etc.);
2. the validator pipeline;
3. the transformers;
4. the mapping over arrays if `.array()` is enabled.

### Example

```ts
o.string().trim().min(3).parse("  hello  ");
// â†’ "hello"
```

### In Case of Error

`parse()` throws an exception containing:

* either the custom error message (`params.error`),
* or the validator name.

---

## safeParse()

Safe version that never throws.

```ts
schema.safeParse("ok");
// { value: "ok" }

schema.safeParse(123);
// { error: "must be string", value: 123 }
```

Useful for:

* form handling,
* backend APIs,
* silent validation.

---

## Full Example of a Custom Schema

```ts
class PositiveNumber extends BaseSchema<number> {
  constructor() {
    super("number", [
      {
        schema: "number",
        type: "validator",
        params: { error: "must be a number" }
      },
      {
        schema: "positive",
        type: "validator",
        params: { error: "must be positive" }
      }
    ]);
  }
}

const age = new PositiveNumber().optional().default(18);
age.parse(undefined); // 18
```

---

## Conclusion

Ody Core provides a simple, fast, and modular engine.

It serves as the foundation enabling:

* advanced schemas (object, tuple, union, record),
* extending Ody with custom rules,
* creating a modern and intuitive DX.

